namespace Zomp.SyncMethodGenerator;

/// <summary>
/// Contains routinge to construct a generated source file with a synchronized method
/// </summary>
public static class SourceGenerationHelper
{
    internal const string Attribute = """
// <auto-generated/>
namespace Zomp.SyncMethodGenerator
{
    /// <summary>
    /// An attribute that can be used to automatically generate a synchronous version of an async method. Must be used in a parital class.
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Method)]
    internal class CreateSyncVersionAttribute : System.Attribute
    {
    }
}
""";

    internal static string GenerateExtensionClass(MethodToGenerate methodToGenerate)
    {
        static string GetKeyword(SyntaxKind sk)
        {
            return sk switch
            {
                SyntaxKind.PublicKeyword => "public",
                SyntaxKind.InternalKeyword => "internal",
                SyntaxKind.PrivateKeyword => "private",
                SyntaxKind.SealedKeyword => "sealed",
                SyntaxKind.ProtectedKeyword => "protected",
                SyntaxKind.StaticKeyword => "static",
                _ => throw new InvalidOperationException($"{sk} is not supported"),
            };
        }

        // Handle namespaces

        var sbBegin = new StringBuilder();
        var sbEnd = new StringBuilder();
        var i = 0;

        if (!methodToGenerate.IsNamespaceFileScoped)
        {
            foreach (var @namespace in methodToGenerate.Namespaces)
            {
                var indent = new string(' ', 4 * i);
                sbBegin.Append($$"""
{{indent}}namespace {{@namespace}}
{{indent}}{

""");
                sbEnd.Insert(0, $$"""
{{indent}}}

""");
                ++i;
            }
        }

        // Handle classes

        foreach (var @class in methodToGenerate.Classes)
        {
            var indent = new string(' ', 4 * i);

            var modifiers = string.Join(string.Empty, @class.Modifiers.Select(z => GetKeyword(z) + " "));
            var classDeclarationLine = $"{modifiers}partial class {@class.ClassName}{(@class.TypeParameterListSyntax is null ? ""
                : "<" + string.Join(", ", @class.TypeParameterListSyntax.Parameters.Select(z => z.ToString())) + ">")}";

            sbBegin.Append($$"""
{{indent}}{{classDeclarationLine}}
{{indent}}{

""");
            sbEnd.Insert(0, $$"""
{{indent}}}

""");
            ++i;
        }

        var beforeNamespace = """
// <auto-generated/>
#nullable enable
""";

        return methodToGenerate.IsNamespaceFileScoped ? $$"""
{{beforeNamespace}}
namespace {{methodToGenerate.Namespaces.First()}};
{{sbBegin}}{{new string(' ', 4 * i)}}{{methodToGenerate.Implementation.Trim()}}
{{sbEnd}}
"""
            : $$"""
{{beforeNamespace}}
{{sbBegin}}{{new string(' ', 4 * i)}}{{methodToGenerate.Implementation.Trim()}}
{{sbEnd}}
""";
    }
}
