namespace Zomp.SyncMethodGenerator;

/// <summary>
/// Contains routines to construct a generated source file with a synchronized method.
/// </summary>
public static class SourceGenerationHelper
{
    internal const string CreateSyncVersionAttributeSource = $$"""
// <auto-generated/>
namespace Zomp.SyncMethodGenerator
{
    #if !SYNC_METHOD_GENERATOR_DISABLE_ATTRIBUTE_GENERATION
    /// <summary>
    /// An attribute that can be used to automatically generate a synchronous version of an async method. Must be used in a partial class.
    /// </summary>
    [System.AttributeUsage(
        System.AttributeTargets.Method |
        System.AttributeTargets.Class |
        System.AttributeTargets.Struct |
        System.AttributeTargets.Interface,
        AllowMultiple = false,
        Inherited = false)]
    internal class {{SyncMethodSourceGenerator.CreateSyncVersionAttribute}} : System.Attribute
    {
        /// <summary>
        /// Gets or sets a value indicating whether "#nullable enable" directive will be omitted from generated code. False by default.
        /// </summary>
        public bool {{SyncMethodSourceGenerator.OmitNullableDirective}} { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether <see cref="System.IProgress{T}"/> parameters will be preserved in the generated code. False by default.
        /// </summary>
        public bool {{SyncMethodSourceGenerator.PreserveProgress}} { get; set; }
    }
    #endif
}
""";

    internal const string SkipSyncVersionAttributeSource = $$"""
// <auto-generated/>
namespace Zomp.SyncMethodGenerator
{
    #if !SYNC_METHOD_GENERATOR_DISABLE_ATTRIBUTE_GENERATION
    /// <summary>
    /// An attribute that can be used to skip automatic generation of a synchronous version of an async method.
    ///
    /// This is useful when the containing type (class, struct, or interface) is marked with <see cref="CreateSyncVersionAttribute"/>,
    /// which would otherwise cause all async methods in that type to have their synchronous versions generated automatically.
    /// Applying this attribute to a specific method will prevent its synchronous version from being generated,
    /// even if the type-level <see cref="CreateSyncVersionAttribute"/> is present.
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    internal class {{SyncMethodSourceGenerator.SkipSyncVersionAttribute}} : System.Attribute
    {
    }
    #endif
}
""";

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE0072:Add missing cases", Justification = "Only deal with selected SyntaxKinds")]
    internal static string GenerateExtensionClass(MethodToGenerate methodToGenerate)
    {
        static string GetKeyword(SyntaxKind sk) => sk switch
        {
            SyntaxKind.PublicKeyword => "public",
            SyntaxKind.InternalKeyword => "internal",
            SyntaxKind.PrivateKeyword => "private",
            SyntaxKind.SealedKeyword => "sealed",
            SyntaxKind.ProtectedKeyword => "protected",
            SyntaxKind.StaticKeyword => "static",
            SyntaxKind.AbstractKeyword => "abstract",
            _ => throw new InvalidOperationException($"{sk} is not supported"),
        };

        // Handle namespaces
        var sbBegin = new StringBuilder();
        var sbEnd = new StringBuilder();
        var i = 0;

        if (!methodToGenerate.IsNamespaceFileScoped)
        {
            foreach (var @namespace in methodToGenerate.Namespaces)
            {
                var indent = new string(' ', 4 * i);
                _ = sbBegin.Append($$"""
{{indent}}namespace {{@namespace}}
{{indent}}{

""");
                _ = sbEnd.Insert(0, $$"""
{{indent}}}

""");
                ++i;
            }
        }

        // Handle classes
        foreach (var parent in methodToGenerate.Parents)
        {
            var indent = new string(' ', 4 * i);

            var modifiers = string.Join(string.Empty, parent.Modifiers.Select(z => GetKeyword((SyntaxKind)z) + " "));
            var parentType = parent.MethodParent switch
            {
                MethodParent.Class => "class",
                MethodParent.Interface => "interface",
                MethodParent.Struct => "struct",
                MethodParent.Record => "record"
                + parent.ClassOrStructKeyword.Kind() switch
                {
                    SyntaxKind.StructKeyword => " struct",
                    SyntaxKind.ClassKeyword => " class",
                    _ => string.Empty,
                },
                _ => throw new NotImplementedException("Cannot handle the parent of the method"),
            };

            var classDeclarationLine = $"{modifiers}partial {parentType} {parent.ParentName}{(parent.TypeParameterListSyntax.IsEmpty ? string.Empty
                : "<" + string.Join(", ", parent.TypeParameterListSyntax) + ">")}";

            _ = sbBegin.Append($$"""
{{indent}}{{classDeclarationLine}}
{{indent}}{

""");
            _ = sbEnd.Insert(0, $$"""
{{indent}}}

""");
            ++i;
        }

        var beforeNamespace = $"""
// <auto-generated/>{(methodToGenerate.DisableNullable ? string.Empty : """

#nullable enable
""")}
""";

        return methodToGenerate.IsNamespaceFileScoped ? $$"""
{{beforeNamespace}}
namespace {{methodToGenerate.Namespaces.First()}};
{{sbBegin}}{{new string(' ', 4 * i)}}{{methodToGenerate.Implementation.Trim()}}
{{sbEnd}}
"""
            : $$"""
{{beforeNamespace}}
{{sbBegin}}{{new string(' ', 4 * i)}}{{methodToGenerate.Implementation.Trim()}}
{{sbEnd}}
""";
    }
}
